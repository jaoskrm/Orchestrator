Great, this is a good moment to **lock the direction** before touching code. I‚Äôll treat **your current repo as the baseline** and outline a **clear, staged plan** that directly answers:

> ‚Äúwhat‚Äôs the current plan starting from this version as the base‚Äù

No implementation yet ‚Äî only **architecture, responsibilities, and sequencing**.

---

## 0Ô∏è‚É£ Baseline: What your system already does well

From the traces + code you shared, your orchestrator already has these strengths:

* ‚úÖ **Deterministic structure enforcement**

  * `# === IMPLEMENTATION ===` / `# === TESTS ===`
* ‚úÖ **Round-based retries**
* ‚úÖ **Docker-isolated pytest execution**
* ‚úÖ **Trace observability**
* ‚úÖ **Verifier feedback loop**
* ‚ùå **Stateless retries (full regeneration every time)**
* ‚ùå **No failure classification**
* ‚ùå **No locality awareness**
* ‚ùå **Prompt-only ‚Äúfixes‚Äù instead of system guarantees**

Everything we add should **preserve these strengths** and only evolve the weak points.

---

## 1Ô∏è‚É£ Core architectural shift (the big idea)

### From:

> ‚ÄúGenerate ‚Üí Test ‚Üí Fail ‚Üí Regenerate everything‚Äù

### To:

> **‚ÄúGenerate ‚Üí Freeze ‚Üí Diagnose ‚Üí Patch ‚Üí Re-test‚Äù**

This introduces **code as a first-class artifact**, not a disposable string.

---

## 2Ô∏è‚É£ New conceptual layers (no code yet)

### A. Stable Code Artifact (central concept)

Treat the solver output as a **mutable document with identity**, not a throwaway.

Logical structure:

```
CodeArtifact
‚îú‚îÄ‚îÄ implementation (string / AST)
‚îú‚îÄ‚îÄ tests (string / AST)
‚îú‚îÄ‚îÄ invariants
‚îÇ   ‚îú‚îÄ‚îÄ public API signatures
‚îÇ   ‚îú‚îÄ‚îÄ section markers
‚îÇ   ‚îú‚îÄ‚îÄ tests that already pass
```

**Invariant rule:**
Anything that already passes must not be broken by patches.

---

### B. Failure Classification (formalized)

You already identified the right 4 classes. Now we **operationalize them**.

| Failure Class      | Definition                         | Typical Symptoms                   |
| ------------------ | ---------------------------------- | ---------------------------------- |
| **FORMAT**         | Code cannot be parsed/imported     | SyntaxError, stray ```             |
| **CONTRACT**       | Input/output expectations violated | Missing TypeError, wrong exception |
| **RUNTIME SAFETY** | Unsafe access                      | `.lower()` on None, index error    |
| **LOGIC**          | Wrong computation                  | Incorrect prime result             |

---

## 3Ô∏è‚É£ Decision matrix (this is the heart)

### Immediate rejection vs refinement

| Failure Class      | Action               | Reason                   |
| ------------------ | -------------------- | ------------------------ |
| **FORMAT**         | ‚ùå Reject immediately | No stable AST to patch   |
| **CONTRACT**       | üîÅ Patch             | Usually guard clauses    |
| **RUNTIME SAFETY** | üîÅ Patch             | Highly local, mechanical |
| **LOGIC**          | üîÅ Patch             | Function-level edits     |

Only **FORMAT** forces full regeneration.

Everything else attempts **patch-based refinement first**.

---

## 4Ô∏è‚É£ Refinement philosophy (non-hardcoded, scalable)

You were absolutely right to reject ‚Äúhardcoded rules like `if category is not None`‚Äù.

Instead, we rely on **derived constraints**, not fixed ones.

### Example (from your trace)

Failure:

```
AttributeError: 'NoneType' object has no attribute 'lower'
```

System inference (not prompt hardcoding):

* Input type includes Optional
* Operation requires non-null
* Missing guard

‚Üí Classified as **RUNTIME SAFETY**

‚Üí Allowed patch scope:

```
Add minimal guard before unsafe access
```

This scales to:

* dict access
* index access
* division
* optional attributes
* file handles
* etc.

No domain-specific hacks.

---

## 5Ô∏è‚É£ Failure locality (why patches work)

Your traces already contain enough signal.

Minimum viable locality:

1. Parse pytest output:

   * failing test name
   * traceback line number
2. Map line ‚Üí owning function
3. Restrict edits to:

   * that function body
   * or that validation block

Future upgrade:

* AST-based node replacement (safe, precise)

---

## 6Ô∏è‚É£ Patch policy (what is allowed to change)

This prevents regressions and solver chaos.

### Per failure class:

#### CONTRACT

Allowed:

* Input validation
* Exception type/message
  Forbidden:
* Algorithm rewrite
* Test changes

#### RUNTIME SAFETY

Allowed:

* Guard clauses
* Short-circuit returns
  Forbidden:
* Logic refactors

#### LOGIC

Allowed:

* Arithmetic / condition changes inside function
  Forbidden:
* Signature changes
* Test edits
* Guard removal

---

## 7Ô∏è‚É£ Retry escalation ladder (important)

Refinement should **escalate slowly**, never jump.

1. Patch implementation only
2. Retry tests
3. If same failure repeats ‚Üí stronger constraint
4. If failure set unchanged after N patches ‚Üí regenerate implementation only
5. Absolute last resort ‚Üí full regeneration

This fixes the ‚Äústuck loop‚Äù seen in your prime-number trace.

---

## 8Ô∏è‚É£ Prompt evolution (conceptual, not text yet)

Prompts stop saying:

> ‚ÄúRewrite code fixing errors‚Äù

They start saying:

> ‚ÄúHere is the current code.
> Apply the smallest possible change to fix **this exact failure**.
> You may not modify unrelated functions.‚Äù

This aligns the model with **editor behavior**, not author behavior.

---

## 9Ô∏è‚É£ Where this fits in your repo (high-level)

Conceptually:

* `workflows/coding.py`

  * becomes **artifact manager**
* `judge/judge.py`

  * becomes **failure classifier**
* new internal concept (not file yet):

  * `PatchPlan`
  * `FailureClass`
  * `EditScope`

No UI, CLI, runner, or storage changes needed initially.

---

## üîü Current plan summary (TL;DR)

Starting from **this exact version**, the plan is:

1. **Freeze solver output as a persistent artifact**
2. **Classify pytest failures into 4 types**
3. **Reject FORMAT failures immediately**
4. **Patch, don‚Äôt regenerate, for others**
5. **Restrict edits by failure class**
6. **Escalate only when refinement fails**
7. **Only later add AST enforcement**

This is **how you turn an LLM from a writer into a maintainer**.

---

### Next question for you (conceptual, not coding):

Do you want the **first refinement implementation** to be:

* **Text-diff based** (simpler, faster)
* or **AST-node based** (safer, harder, but future-proof)?

Your answer determines the next design layer.
